id: import_csv
namespace: lovelace

description: Import CSV robuste via Python (Pandas + ClickHouse Connect).

triggers:
  - id: import_webhook
    type: io.kestra.plugin.core.trigger.Webhook
    key: lovelace_secret_key

tasks:
  - id: log_start
    type: io.kestra.plugin.core.log.Log
    message: "üöÄ Traitement Python pour le jeu {{ trigger.body.gameId }}"

  - id: python_import
    type: io.kestra.plugin.scripts.python.Script
    containerImage: python:3.11
    taskRunner:
      type: io.kestra.plugin.scripts.runner.docker.Docker
      networkMode: lovelace-infra_default
    beforeCommands:
      - pip install pandas clickhouse-connect s3fs
    env:
      CH_HOST: lovelace-clickhouse
      CH_PORT: "8123"
      CH_USER: "{{ secret('CH_USER') }}"
      CH_PASSWORD: "{{ secret('CH_PASSWORD') }}"
      S3_KEY: "{{ secret('S3_ACCESS_KEY') }}"
      S3_SECRET: "{{ secret('S3_SECRET_KEY') }}"
      S3_ENDPOINT: "http://lovelace-s3:9000"
    script: |
      import pandas as pd
      import clickhouse_connect
      import os
      import json
      import csv
      from urllib.parse import urlparse

      # 1. Configuration et Inputs
      game_id = "{{ trigger.body.gameId }}"
      target_table = "{{ trigger.body.targetTable }}"
      s3_url = "{{ trigger.body.s3Url }}"
      mapping = {{ trigger.body.mapping }} 

      print(f"üì• Lecture de: {s3_url}")
      print(f"üó∫Ô∏è Mapping: {mapping}")

      storage_options = {
          "key": os.environ["S3_KEY"],
          "secret": os.environ["S3_SECRET"],
          "client_kwargs": {
              "endpoint_url": os.environ["S3_ENDPOINT"]
          }
      }

      parsed = urlparse(s3_url)
      path_parts = parsed.path.strip("/").split("/", 1)
      bucket = path_parts[0]
      key = path_parts[1]
      s3_path = f"s3://{bucket}/{key}"

      # 2. Lecture du CSV (d√©tection du s√©parateur)
      try:
          # On tente de lire les premi√®res lignes pour sniffer le dialecte
          # (Note: avec s3fs direct dans read_csv, sniffer est compliqu√©, 
          # on va plut√¥t tenter sep=None engine='python' qui auto-d√©tecte)
          df = pd.read_csv(
              s3_path, 
              storage_options=storage_options, 
              sep=None, 
              engine='python'
          )
          
          # Nettoyage des noms de colonnes (enlever les quotes √©ventuelles)
          df.columns = [c.replace('"', '').replace("'", "").strip() for c in df.columns]
          
          print(f"‚úÖ CSV charg√©: {len(df)} lignes, colonnes d√©tect√©es: {list(df.columns)}")
      except Exception as e:
          print(f"‚ùå Erreur lecture CSV: {e}")
          raise

      # 3. Application du Mapping et Nettoyage
      rename_map = {v: k for k, v in mapping.items()}
      
      # V√©rification insensible √† la casse et aux quotes r√©siduelles
      normalized_cols = {c.lower(): c for c in df.columns}
      
      final_rename_map = {}
      for csv_col, target_col in rename_map.items():
          norm_csv_col = csv_col.lower().replace('"', '').replace("'", "").strip()
          if norm_csv_col in normalized_cols:
              real_col_name = normalized_cols[norm_csv_col]
              final_rename_map[real_col_name] = target_col
          else:
              print(f"‚ö†Ô∏è Colonne mapp√©e '{csv_col}' non trouv√©e dans {list(df.columns)}")
              raise ValueError(f"Colonne '{csv_col}' absente du CSV")

      df = df.rename(columns=final_rename_map)
      target_cols = list(final_rename_map.values())
      df = df[target_cols]

      df['game_id'] = game_id
      df = df.where(pd.notnull(df), None)

      print(f"‚ú® DataFrame pr√™t pour import: {list(df.columns)}")

      # 4. Envoi vers ClickHouse
      try:
          client = clickhouse_connect.get_client(
              host=os.environ["CH_HOST"],
              port=int(os.environ["CH_PORT"]),
              username=os.environ["CH_USER"],
              password=os.environ["CH_PASSWORD"]
          )

          client.insert_df(target_table, df)
          print(f"üöÄ Succ√®s! {len(df)} lignes ins√©r√©es dans {target_table}.")
      except Exception as e:
          print(f"‚ùå Erreur ClickHouse: {e}")
          raise

  - id: notify_lovelace_success
    type: io.kestra.plugin.core.http.Request
    uri: "http://100.111.190.11:3000/admin/onboarding/{{ trigger.body.gameId }}/{{ trigger.body.stepSlug }}/complete"
    method: POST
    contentType: JSON
    body:
      status: "completed"